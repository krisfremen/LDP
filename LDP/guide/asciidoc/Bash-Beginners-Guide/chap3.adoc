[[chap_03]]
The Bash environment
--------------------

_________________________________________________________________________________________________
In this chapter we will discuss the various ways in which the Bash
environment can be influenced:

* Editing shell initialization files
* Using variables
* Using different quote styles
* Perform arithmetic calculations
* Assigning aliases
* Using expansion and substitution
_________________________________________________________________________________________________

[[sect_03_01]]
Shell initialization files
--------------------------

[[sect_03_01_01]]
System-wide configuration files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[sect_03_01_01_01]]
/etc/profile
^^^^^^^^^^^^

When invokedconfiguration files/etc/profile interactively with the
`--login` option or when invoked as `sh`, Bash reads the `/etc/profile`
instructions. These usually set the shell variables `PATHvariablesPATH`,
`USERvariablesUSER`, `MAILvariablesMAIL`, `HOSTNAMEvariablesHOSTNAME`
and `HISTSIZEvariablesHISTSIZE`.

On some systems, the `umask` value is configured in `/etc/profile`; on
other systems this file holds pointers to other configuration files such
as:

* `/etc/inputrcconfiguration files/etc/inputrc`, the system-wide
Readline initialization file where you can configure the command line
bell-style.
* the `/etc/profile.d` directoryconfiguration files/etc.profile.d, which
contains files configuring system-wide behavior of specific programs.

All settings that you want to apply to all your users' environments
should be in this file. It might look like this/etc/profileexample:

....
# /etc/profile

# System wide environment and startup programs, for login setup

PATH=$PATH:/usr/X11R6/bin

# No core files by default
ulimit -S -c 0 > /dev/null 2>&1

USER="`id -un`"
LOGNAME=$USER
MAIL="/var/spool/mail/$USER"

HOSTNAME=`/bin/hostname`
HISTSIZE=1000

# Keyboard, bell, display style: the readline config file:
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ]; then
    INPUTRC=/etc/inputrc
fi

PS1="\u@\h \W"

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC PS1

# Source initialization files for specific programs (ls, vim, less, ...)
for i in /etc/profile.d/*.sh ; do
    if [ -r "$i" ]; then
        . $i
    fi
done

# Settings for program initialization
source /etc/java.conf
export NPX_PLUGIN_PATH="$JRE_HOME/plugin/ns4plugin/:/usr/lib/netscape/plugins"

PAGER="/usr/bin/less"

unset i
....

This configuration file sets some basic shell environment variables as
well as some variables required by users running Java and/or Java
applications in their web browser. See link:#sect_03_02[Variables].

See link:#chap_07[???] for more on the conditional `if` used in this
file; link:#chap_09[???] discusses loops such as the `for` construct.

The Bash source contains sample `profile` files for general or
individual use. These and the one in the example above need changes in
order for them to work in your environment!

[[sect_03_01_01_02]]
/etc/bashrc
^^^^^^^^^^^

On systems offering multiple types of shells, it might be better to put
Bash-specific configurations in this fileconfiguration files/etc/bashrc,
since `/etc/profile` is also read by other shells, such as the Bourne
shell. Errors generated by shells that don't understand the Bash syntax
are prevented by splitting the configuration files for the different
types of shells. In such cases, the user's `~/.bashrc` might point to
`/etc/bashrc` in order to include it in the shell initialization process
upon login.

You might also find that `/etc/profile` on your system only holds shell
environment and program startup settings, while `/etc/bashrc` contains
system-wide definitions for shell functions and aliasesaliasesexamples.
The `/etc/bashrc` file might be referred to in `/etc/profile` or in
individual user shell initialization files.

The source contains sample `bashrc` files, or you might find a copy in
`/usr/share/doc/bash-2.05b/startup-files`. This is part of the `bashrc`
that comes with the Bash documentation/etc/bashrcexample:

....
alias ll='ls -l'
alias dir='ls -ba'
alias c='clear'
alias ls='ls --color'

alias mroe='more'
alias pdw='pwd'
alias sl='ls --color'

pskill()
{
        local pid

        pid=$(ps -ax | grep $1 | grep -v grep | gawk '{ print $1 }')
        echo -n "killing $1 (process $pid)..."
        kill -9 $pid
        echo "slaughtered."
}
....

Apart from general aliases, it contains useful aliases which make
commands work even if you misspellaliasesmisspelled commands them. We
will discuss aliases in link:#sect_03_05_02[Creating and removing
aliases]. This file contains a function, `pskill`; functions will be
studied in detail in link:#chap_11[???].

[[sect_03_01_02]]
Individual user configuration files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

__________________________________________________________________________________
*Note*

These files might not be in your home directory by default; create them
if needed.
__________________________________________________________________________________

[[sect_03_01_02_01]]
~/.bash_profile
^^^^^^^^^^^^^^^

This is the preferred configuration file for configuring user
environments individuallyconfiguration files.bash_profile. In this file,
users can add extra configuration options or change default settings:

....
franky~> cat .bash_profile.bash_profileexample
#################################################################
#                                                               #
#   .bash_profile file                                          #
#                                                               #
#   Executed from the bash shell when you log in.               #
#                                                               #
#################################################################

source ~/.bashrc
source ~/.bash_login
case "$OS" in
  IRIX)
    stty sane dec
    stty erase
    ;;
#  SunOS)
#    stty erase
#    ;;
  *)
    stty sane
    ;;
esac
....

This user configures the backspace character for login on different
operating systems. Apart from that, the user's `.bashrc` and
`.bash_login` are read.

[[sect_03_01_02_02]]
~/.bash_login
^^^^^^^^^^^^^

This fileconfiguration files.bash_login contains specific settings that
are normally only executed when you log in to the system. In the
example, we use it to configure the `umask` value and to show a list of
connected users upon login. This user also gets the calendar for the
current month.bash_loginexample:

....
#######################################################################
#                                                                     #
#   Bash_login file                                                   #
#                                                                     #
#   commands to perform from the bash shell at login time             #
#   (sourced from .bash_profile)                                      #
#                                                                     #
#######################################################################
#   file protection
umask 002       # all to me, read to group and others
#   miscellaneous
w
cal `date +"%m"` `date +"%Y"`
....

In the absence of `~/.bash_profile`, this file will be read.

[[sect_03_01_02_03]]
~/.profile
^^^^^^^^^^

In the absenceconfiguration files.profile of `~/.bash_profile` and
`~/.bash_login`, `~/.profile` is read. It can hold the same
configurations, which are then also accessible by other shells. Mind
that other shells might not understand the Bash syntax.

[[sect_03_01_02_04]]
~/.bashrc
^^^^^^^^^

Today, it is more commonconfiguration files.bashrc to use a non-login
shell, for instance when logged in graphically using X terminal windows.
Upon opening such a window, the user does not have to provide a user
name or password; no authentication is done. Bash searches for
`~/.bashrc` when this happens, so it is referred to in the files read
upon login as well, which means you don't have to enter the same
settings in multiple files.

In this user's `.bashrc` a couple of aliasesaliasesexamples are defined
and variables for specific programs are set after the system-wide
`/etc/bashrc` is read.bashrcexample:

....
franky ~> cat .bashrc
# /home/franky/.bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
       . /etc/bashrc

fi

# shell options

set -o noclobber

# my shell variables

export PS1="\[\033[1;44m\]\u \w\[\033[0m\] "
export PATH="$PATH:~/bin:~/scripts"

# my aliases

alias cdrecord='cdrecord -dev 0,0,0 -speed=8'
alias ss='ssh octarine'
alias ll='ls -la'

# mozilla fix

MOZILLA_FIVE_HOME=/usr/lib/mozilla
LD_LIBRARY_PATH=/usr/lib/mozilla:/usr/lib/mozilla/plugins
MOZ_DIST_BIN=/usr/lib/mozilla
MOZ_PROGRAM=/usr/lib/mozilla/mozilla-bin
export MOZILLA_FIVE_HOME LD_LIBRARY_PATH MOZ_DIST_BIN MOZ_PROGRAM

# font fix
alias xt='xterm -bg black -fg white &'

# BitchX settings
export IRCNAME="frnk"

# THE END
franky ~>
....

More examples can be found in the Bash package. Remember that sample
files might need changes in order to work in your environment.

Aliases are discussed in link:#sect_03_05[Aliases].

[[sect_03_01_02_05]]
~/.bash_logout
^^^^^^^^^^^^^^

This file contains specific instructions for the logoutconfiguration
files.bash_logout procedure. In the example.bash_logoutexample, the
terminal window is cleared upon logout. This is useful for remote
connections, which will leave a clean window after closing them.

....
franky ~> cat .bash_logout
#######################################################################
#                                                                     #
#   Bash_logout file                                                  #
#                                                                     #
#   commands to perform from the bash shell at logout time            #
#                                                                     #
#######################################################################
clear
franky ~>
....

[[sect_03_01_03]]
Changing shell configuration files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When making changesconfiguration fileschange shell configuration to any
of the above files, users have to either reconnect to the system or
`source` the altered file for the changes to take effect. By
interpreting the script this way, changesconfiguration filesprompt are
applied to the current shell session:

image:images/prompt.eps[Different prompts for different users]

Most shell scripts execute in a private environment: variables are not
inherited by child processes unless they are exported by the parent
shell. Sourcing a file containing shell commands is a way of applying
changes to your own environment and setting variables in the current
shell.

This example also demonstrates the use of different prompt settings by
different users. In this case, red means danger. When you have a green
prompt, don't worry too much.

Note that `source resourcefile` is the same as `. resourcefile`.

Should you get lost in all these configuration files, and find yourself
confronted with settings of which the origin is not clear, use `echo`
statements, just like for debugging scripts; see
link:#sect_02_03_02[???]. You might add lines like this:

....
echo "Now executing .bash_profile.."
....

or like this:

....
echo "Now setting PS1 in .bashrc:"
export PS1="[some value]"
echo "PS1 is now set to $PS1"
....

[[sect_03_02]]
Variables
---------

[[sect_03_02_01]]
Types of variables
~~~~~~~~~~~~~~~~~~

As seen in the examples above, shell variablesvariablestypes are in
uppercase characters by convention. Bash keeps a list of two types of
variables:

[[sect_03_02_01_01]]
Global variables
^^^^^^^^^^^^^^^^

Global variablesvariablesglobal variables or
environmentvariablesenvironment variables variables are available in all
shells. The `envcommandsenv` or `printenvcommandsprintenv` commands can
be used to display environment variables. These programs come with the
_sh-utils_ packagecommandssh-utils package.

Below is a typical outputprintenvexample:

....
franky ~> printenv
CC=gcc
CDPATH=.:~:/usr/local:/usr:/
CFLAGS=-O2 -fomit-frame-pointer
COLORTERM=gnome-terminal
CXXFLAGS=-O2 -fomit-frame-pointer
DISPLAY=:0
DOMAIN=hq.garrels.be
e=
TOR=vi
FCEDIT=vi
FIGNORE=.o:~
G_BROKEN_FILENAMES=1
GDK_USE_XFT=1
GDMSESSION=Default
GNOME_DESKTOP_SESSION_ID=Default
GTK_RC_FILES=/etc/gtk/gtkrc:/nethome/franky/.gtkrc-1.2-gnome2
GWMCOLOR=darkgreen
GWMTERM=xterm
HISTFILESIZE=5000
history_control=ignoredups
HISTSIZE=2000
HOME=/nethome/franky
HOSTNAME=octarine.hq.garrels.be
INPUTRC=/etc/inputrc
IRCNAME=franky
JAVA_HOME=/usr/java/j2sdk1.4.0
LANG=en_US
LDFLAGS=-s
LD_LIBRARY_PATH=/usr/lib/mozilla:/usr/lib/mozilla/plugins
LESSCHARSET=latin1
LESS=-edfMQ
LESSOPEN=|/usr/bin/lesspipe.sh %s
LEX=flex
LOCAL_MACHINE=octarine
LOGNAME=franky
LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:
MACHINES=octarine
MAILCHECK=60
MAIL=/var/mail/franky
MANPATH=/usr/man:/usr/share/man/:/usr/local/man:/usr/X11R6/man
MEAN_MACHINES=octarine
MOZ_DIST_BIN=/usr/lib/mozilla
MOZILLA_FIVE_HOME=/usr/lib/mozilla
MOZ_PROGRAM=/usr/lib/mozilla/mozilla-bin
MTOOLS_FAT_COMPATIBILITY=1
MYMALLOC=0
NNTPPORT=119
NNTPSERVER=news
NPX_PLUGIN_PATH=/plugin/ns4plugin/:/usr/lib/netscape/plugins
OLDPWD=/nethome/franky
OS=Linux
PAGER=less
PATH=/nethome/franky/bin.Linux:/nethome/franky/bin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:/usr/bin:/usr/sbin:/bin:/sbin:.
PS1=\[\033[1;44m\]franky is in \w\[\033[0m\]
PS2=More input>
PWD=/nethome/franky
SESSION_MANAGER=local/octarine.hq.garrels.be:/tmp/.ICE-unix/22106
SHELL=/bin/bash
SHELL_LOGIN=--login
SHLVL=2
SSH_AGENT_PID=22161
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
SSH_AUTH_SOCK=/tmp/ssh-XXmhQ4fC/agent.22106
START_WM=twm
TERM=xterm
TYPE=type
USERNAME=franky
USER=franky
_=/usr/bin/printenv
VISUAL=vi
WINDOWID=20971661
XAPPLRESDIR=/nethome/franky/app-defaults
XAUTHORITY=/nethome/franky/.Xauthority
XENVIRONMENT=/nethome/franky/.Xdefaults
XFILESEARCHPATH=/usr/X11R6/lib/X11/%L/%T/%N%C%S:/usr/X11R6/lib/X11/%l/%T/%N%C%S:/usr/X11R6/lib/X11/%T/%N%C%S:/usr/X11R6/lib/X11/%L/%T/%N%S:/usr/X11R6/lib/X11/%l/%T/%N%S:/usr/X11R6/lib/X11/%T/%N%S
XKEYSYMDB=/usr/X11R6/lib/X11/XKeysymDB
XMODIFIERS=@im=none
XTERMID=
XWINHOME=/usr/X11R6
X=X11R6
YACC=bison -y
....

[[sect_03_02_01_02]]
Local variables
^^^^^^^^^^^^^^^

Local variablesvaribleslocal variables are only available in the current
shell. Using the `set` built-in command without any options will display
a list of all variables (including environment variables) and functions.
The output will be sorted according to the current locale and displayed
in a reusable format.

Below is a diff file made by comparing `printenv` and `set` output,
after leaving out the functions which are also displayed by the `set`
command:

....
franky ~> diff set.sorted printenv.sorted | grep "<" | awk '{ print $2 }'
BASE=/nethome/franky/.Shell/hq.garrels.be/octarine.aliases
BASH=/bin/bash
BASH_VERSINFO=([0]="2"
BASH_VERSION='2.05b.0(1)-release'
COLUMNS=80
DIRSTACK=()
DO_FORTUNE=
EUID=504
GROUPS=()
HERE=/home/franky
HISTFILE=/nethome/franky/.bash_history
HOSTTYPE=i686
IFS=$'
LINES=24
MACHTYPE=i686-pc-linux-gnu
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PIPESTATUS=([0]="0")
PPID=10099
PS4='+
PWD_REAL='pwd
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
THERE=/home/franky
UID=504
....

____________________________________________________________________
*Note*

the GNU Awk programming language is explained in link:#chap_06[???].
____________________________________________________________________

[[sect_03_02_01_03]]
Variables by content
^^^^^^^^^^^^^^^^^^^^

Apart from dividing variables in local and global variables, we can also
divide them in categories according to the sort of content the variable
contains. In this respect, variables come in 4 typesvariablescontent
types:

* String variables
* Integer variables
* Constant variables
* Array variables

We'll discuss these types in link:#chap_10[???]. For now, we will work
with integer and string values for our variables.

[[sect_03_02_02]]
Creating variables
~~~~~~~~~~~~~~~~~~

Variablesvariablescreation are case sensitive and capitalized by
default. Giving local variables a lowercase name is a convention which
is sometimes applied. However, you are free to use the names you want or
to mix cases. Variables can also contain digits, but a name starting
with a digit is not allowed:

....
prompt> export 1number=1
bash: export: `1number=1': not a valid identifier
....

To set a variable in the shell, use

VARNAME

="value"

Putting spaces around the equal sign will cause errors. It is a good
habit to quote content strings when assigning values to variables: this
will reduce the chance that you make errors.

Some examples using upper and lower cases, numbers and spaces:

....
franky ~> MYVAR1="2"

franky ~> echo $MYVAR1
2

franky ~> first_name="Franky"

franky ~> echo $first_name
Franky

franky ~> full_name="Franky M. Singh"

franky ~> echo $full_name
Franky M. Singh

franky ~> MYVAR-2="2"
bash: MYVAR-2=2: command not found

franky ~> MYVAR1 ="2"
bash: MYVAR1: command not found

franky ~> MYVAR1= "2"
bash: 2: command not found

franky ~> unset MYVAR1 first_name full_name

franky ~> echo $MYVAR1 $first_name $full_name
<--no output-->

franky ~>
....

[[sect_03_02_03]]
Exporting variables
~~~~~~~~~~~~~~~~~~~

A variablevariablesexporting created like the ones in the example above
is only available to the current shell. It is a local variable: child
processes of the current shell will not be aware of this variable. In
order to pass variables to a subshell, we need to _export_ them using
the `exportbuilt-insexport` built-in command. Variables that are
exported are referred to as environment variables. Setting and exporting
is usually done in one step:

export

VARNAME

="

value

"

A subshellvariablessubshells can change variables it inherited from the
parent, but the changes made by the child don't affect the parent. This
is demonstrated in the example:

....
franky ~> full_name="Franky M. Singh"

franky ~> bash

franky ~> echo $full_name


franky ~> exit

franky ~> export full_name

franky ~> bash

franky ~> echo $full_name
Franky M. Singh

franky ~> export full_name="Charles the Great"

franky ~> echo $full_name
Charles the Great

franky ~> exit

franky ~> echo $full_name
Franky M. Singh

franky ~>
....

When first trying to read the value of `full_name` in a subshell, it is
not there (`echo` shows a null string). The subshell quits, and
`full_name` is exported in the parent - a variable can be exported after
it has been assigned a value. Then a new subshell is started, in which
the variable exported from the parent is visible. The variable is
changed to hold another name, but the value for this variable in the
parent stays the same.

[[sect_03_02_04]]
Reserved variables
~~~~~~~~~~~~~~~~~~

[[sect_03_02_04_01]]
Bourne shell reserved variables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bash uses certain shell variablesvariablesBourne shell reserved in the
same way as the Bourne shell. In some cases, Bash assigns a default
value to the variable. The table below gives an overview of these plain
shell variables:

.Reserved Bourne shell variables
[cols=",",options="header",]
|=======================================================================
|Variable name |Definition
|CDPATH |A colon-separated list of directories used as a search path for
the `cd` built-in command.

|HOME |The current user's home directory; the default for the `cd`
built-in. The value of this variable is also used by tilde expansion.

|IFS |A list of characters that separate fields; used when the shell
splits words as part of expansion.

|MAIL |If this parameter is set to a file name and the `MAILPATH`
variable is not set, Bash informs the user of the arrival of mail in the
specified file.

|MAILPATH |A colon-separated list of file names which the shell
periodically checks for new mail.

|OPTARG |The value of the last option argument processed by the
`getopts` built-in.

|OPTIND |The index of the last option argument processed by the
`getopts` built-in.

|PATH |A colon-separated list of directories in which the shell looks
for commands.

|PS1 |The primary prompt string. The default value is ``'\s-\v\$ '''.

|PS2 |The secondary prompt string. The default value is ``'> '''.
|=======================================================================

[[sect_03_02_04_02]]
Bash reserved variables
^^^^^^^^^^^^^^^^^^^^^^^

These variables are set or used by BashvariablesBash reserved, but other
shells do not normally treat them specially.

.Reserved Bash variables
[cols=",",options="header",]
|=======================================================================
|Variable name |Definition
|auto_resume |This variable controls how the shell interacts with the
user and job control.

|BASH |The full pathname used to execute the current instance of Bash.

|BASH_ENV |If this variable is set when Bash is invoked to execute a
shell script, its value is expanded and used as the name of a startup
file to read before executing the script.

|BASH_VERSION |The version number of the current instance of Bash.

|BASH_VERSINFO |A read-only array variable whose members hold version
information for this instance of Bash.

|COLUMNS |Used by the `select` built-in to determine the terminal width
when printing selection lists. Automatically set upon receipt of a
_SIGWINCH_ signal.

|COMP_CWORD |An index into `${COMP_WORDS}` of the word containing the
current cursor position.

|COMP_LINE |The current command line.

|COMP_POINT |The index of the current cursor position relative to the
beginning of the current command.

|COMP_WORDS |An array variable consisting of the individual words in the
current command line.

|COMPREPLY |An array variable from which Bash reads the possible
completions generated by a shell function invoked by the programmable
completion facility.

|DIRSTACK |An array variable containing the current contents of the
directory stack.

|EUID |The numeric effective user ID of the current user.

|FCEDIT |The editor used as a default by the `-e` option to the `fc`
built-in command.

|FIGNORE |A colon-separated list of suffixes to ignore when performing
file name completion.

|FUNCNAME |The name of any currently-executing shell function.

|GLOBIGNORE |A colon-separated list of patterns defining the set of file
names to be ignored by file name expansion.

|GROUPS |An array variable containing the list of groups of which the
current user is a member.

|histchars |Up to three characters which control history expansion,
quick substitution, and _tokenization_.

|HISTCMD |The history number, or index in the history list, of the
current command.

|HISTCONTROL |Defines whether a command is added to the history file.

|HISTFILE |The name of the file to which the command history is saved.
The default value is `~/.bash_history`.

|HISTFILESIZE |The maximum number of lines contained in the history
file, defaults to 500.

|HISTIGNORE |A colon-separated list of patterns used to decide which
command lines should be saved in the history list.

|HISTSIZE |The maximum number of commands to remember on the history
list, default is 500.

|HOSTFILE |Contains the name of a file in the same format as
`/etc/hosts` that should be read when the shell needs to complete a
hostname.

|HOSTNAME |The name of the current host.

|HOSTTYPE |A string describing the machine Bash is running on.

|IGNOREEOF |Controls the action of the shell on receipt of an _EOF_
character as the sole input.

|INPUTRC |The name of the Readline initialization file, overriding the
default `/etc/inputrc`.

|LANG |Used to determine the locale category for any category not
specifically selected with a variable starting with `LC_`.

|LC_ALL |This variable overrides the value of `LANG` and any other `LC_`
variable specifying a locale category.

|LC_COLLATE |This variable determines the collation order used when
sorting the results of file name expansion, and determines the behavior
of range expressions, equivalence classes, and collating sequences
within file name expansion and pattern matching.

|LC_CTYPE |This variable determines the interpretation of characters and
the behavior of character classes within file name expansion and pattern
matching.

|LC_MESSAGES |This variable determines the locale used to translate
double-quoted strings preceded by a ``$'' sign.

|LC_NUMERIC |This variable determines the locale category used for
number formatting.

|LINENO |The line number in the script or shell function currently
executing.

|LINES |Used by the `select` built-in to determine the column length for
printing selection lists.

|MACHTYPE |A string that fully describes the system type on which Bash
is executing, in the standard GNU CPU-COMPANY-SYSTEM format.

|MAILCHECK |How often (in seconds) that the shell should check for mail
in the files specified in the `MAILPATH` or `MAIL` variables.

|OLDPWD |The previous working directory as set by the `cd` built-in.

|OPTERR |If set to the value 1, Bash displays error messages generated
by the `getopts` built-in.

|OSTYPE |A string describing the operating system Bash is running on.

|PIPESTATUS |An array variable containing a list of exit status values
from the processes in the most recently executed foreground pipeline
(which may contain only a single command).

|POSIXLY_CORRECT |If this variable is in the environment when `bash`
starts, the shell enters POSIX mode.

|PPID |The process ID of the shell's parent process.

|PROMPT_COMMAND |If set, the value is interpreted as a command to
execute before the printing of each primary prompt (`PS1`).

|PS3 |The value of this variable is used as the prompt for the `select`
command. Defaults to ``'#? '''

|PS4 |The value is the prompt printed before the command line is echoed
when the `-x` option is set; defaults to ``'+ '''.

|PWD |The current working directory as set by the `cd` built-in command.

|RANDOM |Each time this parameter is referenced, a random integer
between 0 and 32767 is generated. Assigning a value to this variable
seeds the random number generator.

|REPLY |The default variable for the `read` built-in.

|SECONDS |This variable expands to the number of seconds since the shell
was started.

|SHELLOPTS |A colon-separated list of enabled shell options.

|SHLVL |Incremented by one each time a new instance of Bash is started.

|TIMEFORMAT |The value of this parameter is used as a format string
specifying how the timing information for pipelines prefixed with the
`time` reserved word should be displayed.

|TMOUT |If set to a value greater than zero, `TMOUT` is treated as the
default timeout for the `read` built-in. In an interative shell, the
value is interpreted as the number of seconds to wait for input after
issuing the primary prompt when the shell is interactive. Bash
terminates after that number of seconds if input does not arrive.

|UID |The numeric, real user ID of the current user.
|=======================================================================

Check the Bash man, info or doc pages for extended information. Some
variables are read-only, some are set automatically and some lose their
meaning when set to a different value than the default.

[[sect_03_02_05]]
Special parameters
~~~~~~~~~~~~~~~~~~

The shell treats several parametersvariablesspecial parameters
specially. These parameters may only be referenced; assignment to them
is not allowed.

.Special bash variables
[cols=",",options="header",]
|=======================================================================
|Character |Definition
|`$*` |Expands to the positional parameters, starting from one. When the
expansion occurs within double quotes, it expands to a single word with
the value of each parameter separated by the first character of the
`IFS` special variable.

|`$@` |Expands to the positional parameters, starting from one. When the
expansion occurs within double quotes, each parameter expands to a
separate word.

|`$#` |Expands to the number of positional parameters in decimal.

|`$?` |Expands to the exit status of the most recently executed
foreground pipeline.

|`$-` |A hyphen expands to the current option flags as specified upon
invocation, by the `set` built-in command, or those set by the shell
itself (such as the `-i`).

|`$$` |Expands to the process ID of the shell.

|`$!` |Expands to the process ID of the most recently executed
background (asynchronous) command.

|`$0` |Expands to the name of the shell or shell script.

|`$_` |The underscore variable is set at shell startup and contains the
absolute file name of the shell or script being executed as passed in
the argument list. Subsequently, it expands to the last argument to the
previous command, after expansion. It is also set to the full pathname
of each command executed and placed in the environment exported to that
command. When checking mail, this parameter holds the name of the mail
file.
|=======================================================================

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
*Note*

The implementation of ``$*'' has always been a problem and realistically
should have been replaced with the behavior of ``$@''. In almost every
case where coders use ``$*'', they mean ``$@''. ``$*'' Can cause bugs
and even security holes in your software.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

The positional parametersvariablespositional parameters are the words
following the name of a shell script. They are put into the variables
`$1`, `$2`, `$3` and so on. As long as needed, variables are added to an
internal array. `$#` holds the total number of parameters, as is
demonstrated with this simplepositional parametersexample script:

....
#!/bin/bash

# positional.sh
# This script reads 3 positional parameters and prints them out.

POSPAR1="$1"
POSPAR2="$2"
POSPAR3="$3"

echo "$1 is the first positional parameter, \$1."
echo "$2 is the second positional parameter, \$2."
echo "$3 is the third positional parameter, \$3."
echo
echo "The total number of positional parameters is $#."
....

Upon execution one could give any numbers of
argumentsargumentspositional parameters:

....
franky ~> positional.sh one two three four five
one is the first positional parameter, $1.
two is the second positional parameter, $2.
three is the third positional parameter, $3.

The total number of positional parameters is 5.

franky ~> positional.sh one two
one is the first positional parameter, $1.
two is the second positional parameter, $2.
 is the third positional parameter, $3.

The total number of positional parameters is 2.
....

More on evaluating these parameters is in link:#chap_07[???] and
link:#sect_09_07[???].

Some examples on the other special parametersspecial parametersexamples:

....
franky ~> grep dictionary /usr/share/dict/words
dictionary

franky ~> echo $_
/usr/share/dict/words

franky ~> echo $$
10662

franky ~> mozilla &
[1] 11064

franky ~> echo $!
11064

franky ~> echo $0
bash

franky ~> echo $?
0

franky ~> ls doesnotexist
ls: doesnotexist: No such file or directory

franky ~> echo $?
1

franky ~>
....

User _franky_ starts entering the `grep` command, which results in the
assignment of the `_` variable. The process ID of his shell is 10662.
After putting a job in the background, the `!` holds the process ID of
the backgrounded job. The shell running is `bash`. When a mistake is
made, `?` holds an exit code different from 0 (zero).

[[sect_03_02_06]]
Script recycling with variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Apartvariablesadvantages from making the script more readable, variables
will also enable you to faster apply a script in another environment or
for another purpose. Consider the following example, a very simple
script that makes a backup of _franky_'s home directory to a remote
server:

....
#!/bin/bash

# This script makes a backup of my home directory.

cd /home

# This creates the archive
tar cf /var/tmp/home_franky.tar franky > /dev/null 2>&1

# First remove the old bzip2 file.  Redirect errors because this generates some if the archive
# does not exist.  Then create a new compressed file.
rm /var/tmp/home_franky.tar.bz2 2> /dev/null
bzip2 /var/tmp/home_franky.tar

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp /var/tmp/home_franky.tar.bz2 bordeaux:/opt/backup/franky > /dev/null 2>&1

# Create a timestamp in a logfile.
date >> /home/franky/log/home_backup.log
echo backup succeeded >> /home/franky/log/home_backup.log
....

First of all, you are more likely to make errors if you name files and
directories manually each time you need them. Secondly, suppose _franky_
wants to give this script to _carol_, then carol will have to do quite
some editing before she can use the script to back up her home
directory. The same is true if _franky_ wants to use this script for
backing up other directories. For easy recycling, make all files,
directories, usernames, servernames etcetera variable. Thus, you only
need to edit a value once, without having to go through the entire
script to check where a parameter occurs. This is an example:

....
#!/bin/bash
                                                                                                 
# This script makes a backup of my home directory.

# Change the values of the variables to make the script work for you:
BACKUPDIR=/home
BACKUPFILES=franky
TARFILE=/var/tmp/home_franky.tar
BZIPFILE=/var/tmp/home_franky.tar.bz2
SERVER=bordeaux
REMOTEDIR=/opt/backup/franky
LOGFILE=/home/franky/log/home_backup.log

cd $BACKUPDIR

# This creates the archive
tar cf $TARFILE $BACKUPFILES > /dev/null 2>&1
                                                                                                 
# First remove the old bzip2 file.  Redirect errors because this generates some if the archive 
# does not exist.  Then create a new compressed file.
rm $BZIPFILE 2> /dev/null
bzip2 $TARFILE

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp $BZIPFILE $SERVER:$REMOTEDIR > /dev/null 2>&1

# Create a timestamp in a logfile.
date >> $LOGFILE
echo backup succeeded >> $LOGFILE
....

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
*Note*

The above is purely an example that everybody can understand, using a
small directory and a host on the same subnet. Depending on your
bandwidth, the size of the directory and the location of the remote
server, it can take an awful lot of time to make backups using this
mechanism. For larger directories and lower bandwidth, use `rsync` to
keep the directories at both ends synchronized.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

[[sect_03_03]]
Quoting characters
------------------

[[sect_03_03_01]]
Why?
~~~~

A lot of keys have special meanings in some context or other. Quoting is
used to remove the special meaning of characters or words: quotes can
disable special treatment for special characters, they can prevent
reserved words from being recognized as such and they can disable
parameter expansion.

[[sect_03_03_02]]
Escape characters
~~~~~~~~~~~~~~~~~

Escape charactersquoting charactersescape characters are used to remove
the special meaning from a single character. A non-quoted backslash, \,
is used as an escape character in Bash. It preserves the literal value
of the next character that follows, with the exception of _newline_. If
a newline character appears immediately after the backslash, it marks
the continuation of a line when it is longer that the width of the
terminal; the backslash is removed from the input stream and effectively
ignored.

....
franky ~> date=20021226

franky ~> echo $date
20021226

franky ~> echo \$date
$date
....

In this example, the variable `date` is created and set to hold a value.
The first `echo` displays the value of the variable, but for the second,
the dollar sign is escaped.

[[sect_03_03_03]]
Single quotes
~~~~~~~~~~~~~

Singlequoting characterssingle quotes quotes ('') are used to preserve
the literal value of each character enclosed within the quotes. A single
quote may not occur between single quotes, even when preceded by a
backslash.

We continue with the previous example:

....
franky ~> echo '$date'
$date
....

[[sect_03_03_04]]
Double quotes
~~~~~~~~~~~~~

Using doublequoting charactersdouble quotes quotes the literal value of
all characters enclosed is preserved, except for the dollar sign, the
backticks (backward single quotes, ``) and the backslash.

The dollar sign and the backticks retain their special meaning within
the double quotes.

The backslash retains its meaning only when followed by dollar,
backtick, double quote, backslash or newline. Within double quotes, the
backslashes are removed from the input stream when followed by one of
these characters. Backslashes preceding characters that don't have a
special meaning are left unmodified for processing by the shell
interpreter.

A double quote may be quoted within double quotes by preceding it with a
backslash.

....
franky ~> echo "$date"
20021226

franky ~> echo "`date`"
Sun Apr 20 11:22:06 CEST 2003

franky ~> echo "I'd say: \"Go for it!\""
I'd say: "Go for it!"

franky ~> echo "\"
More input>"

franky ~> echo "\\"
\
....

[[sect_03_03_05]]
ANSI-C quoting
~~~~~~~~~~~~~~

Wordsquoting charactersANSI-C quoting in the form ``$'STRING''' are
treated in a special way. The word expands to a string, with
backslash-escaped characters replaced as specified by the
ANSI-CANSI-Cquoting standard. Backslash escape sequences can be found in
the Bash documentation.

[[sect_03_03_06]]
Locales
~~~~~~~

A double-quotedquoting characterslocale string preceded by a dollar sign
will cause the string to be translated according to the current locale.
If the current locale is ``C'' or ``POSIX'', the dollar sign is ignored.
If the string is translated and replaced, the replacement is
double-quoted.

[[sect_03_04]]
Shell expansion
---------------

[[sect_03_04_0]]
General
~~~~~~~

After the command has been split into _tokens_ (see
link:#sect_01_04_01_01[???]), these tokens or words are expanded or
resolved. There are eight kinds of expansion performed, which we will
discuss in the next sections, in the order that they are expanded.

After all expansions, quote removal is performed.

[[sect_03_04_01]]
Brace expansion
~~~~~~~~~~~~~~~

Brace expansionexpansionbrace expansion is a mechanism by which
arbitrary strings may be generated. Patterns to be brace-expanded take
the form of an optional _PREAMBLE_, followed by a series of
comma-separated strings between a pair of braces, followed by an
optional _POSTSCRIPT_. The preamble is prefixed to each string contained
within the braces, and the postscript is then appended to each resulting
string, expanding left to right.

Brace expansionsbrace expansionexamples may be nested. The results of
each expanded string are not sorted; left to right order is preserved:

....
franky ~> echo sp{el,il,al}l
spell spill spall
....

Brace expansion is performed before any other expansions, and any
characters special to other expansions are preserved in the result. It
is strictly textual. Bash does not apply any syntactic interpretation to
the context of the expansion or the text between the braces. To avoid
conflicts with parameter expansion, the string ``$\{'' is not considered
eligible for brace expansion.

A correctly-formed brace expansion must contain unquoted opening and
closing braces, and at least one unquoted comma. Any incorrectly formed
brace expansion is left unchanged.

[[sect_03_04_02]]
Tilde expansion
~~~~~~~~~~~~~~~

If a word begins with an unquoted tilde characterexpansiontilde
expansion (``~''), all of the characters up to the first unquoted slash
(or all characters, if there is no unquoted slash) are considered a
_tilde-prefix_. If none of the characters in the tilde-prefix are
quoted, the characters in the tilde-prefix following the tilde are
treated as a possible login name. If this login name is the null string,
the tilde is replaced with the value of the `HOME` shell variable. If
`HOME` is unset, the home directory of the user executing the shell is
substituted instead. Otherwise, the tilde-prefix is replaced with the
home directory associated with the specified login name.

If the tilde-prefixtilde expansionsyntax is ``~+'', the value of the
shell variable `PWD` replaces the tilde-prefix. If the tilde-prefix is
``~-'', the value of the shell variable `OLDPWD`, if it is set, is
substituted.

If the characters following the tilde in the tilde-prefix consist of a
number N, optionally prefixed by a ``+'' or a ``-'', the tilde-prefix is
replaced with the corresponding element from the directory stack, as it
would be displayed by the `dirs` built-in invoked with the characters
following tilde in the tilde-prefix as an argument. If the tilde-prefix,
without the tilde, consists of a number without a leading ``+'' or
``-'', ``+'' is assumed.

If the login name is invalid, or the tilde expansion fails, the word is
left unchanged.

Each variable assignment is checked for unquoted tilde-prefixes
immediately following a ``:'' or ``=''. In these cases, tilde expansion
is also performed. Consequently, one may use file names with tildes in
assignments to `PATH`, `MAILPATH`, and `CDPATH`, and the shell assigns
the expanded value.

Example:

....
franky ~> export PATH="$PATH:~/testdir"
....

`~/testdir` will be expanded to `$HOME``/testdir`, so if `$HOME` is
`/var/home/franky`, the directory `/var/home/franky/testdir` will be
added to the content of the `PATH` variable.

[[sect_03_04_03]]
Shell parameter and variable expansion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``$'' characterexpansionvariable expansion introduces parameter
expansion, command substitution, or arithmetic expansion. The parameter
name or symbol to be expanded may be enclosed in braces, which are
optional but serve to protect the variable to be expanded from
characters immediately following it which could be interpreted as part
of the name.

When braces are used, the matching ending brace is the first ``}'' not
escaped by a backslash or within a quoted string, and not within an
embedded arithmetic expansion, command substitution, or parameter
expansion.

The basic form of parameter expansion is ``$\{PARAMETER}''. The value of
``PARAMETER'' is substituted. The braces are required when ``PARAMETER''
is a positional parameter with more than one digit, or when
``PARAMETER'' is followed by a character that is not to be interpreted
as part of its name.

If the first character of ``PARAMETER'' is an exclamation point, Bash
uses the value of the variable formed from the rest of ``PARAMETER'' as
the name of the variable; this variable is then expanded and that value
is used in the rest of the substitution, rather than the value of
``PARAMETER'' itself. This is known as _indirect expansion_.

You are certainly familiar with straight parameter expansion, since it
happens all the time, even in the simplest of cases, such as the one
above or the followingvariable and parameter expansionexample:

....
franky ~> echo $SHELL
/bin/bash
....

The following is an example of indirect expansionexpansionindirect
expansion:

....
franky ~> echo ${!N*}
NNTPPORT NNTPSERVER NPX_PLUGIN_PATH
....

Note that this is not the same as `echo $N*`.

The following construct allows for creation of the named variable if it
does not yet exist:

$\{

VAR

:=

value

}

Example:

....
franky ~> echo $FRANKY

franky ~> echo ${FRANKY:=Franky}
Franky
....

Special parameters, among others the positional parameters, may not be
assigned this way, however.

We will further discuss the use of the curly braces for treatment of
variables in link:#chap_10[???]. More information can also be found in
the Bash info pages.

[[sect_03_04_04]]
Command substitution
~~~~~~~~~~~~~~~~~~~~

Command substitutionexpansioncommand substitution allows the output of a
command to replace the command itself. Command substitutioncommand
substitutionsyntax occurs when a command is enclosed like this:

$(command)

or like this using backticks:

`command`

Bash performs the expansion by executing COMMAND and replacing the
command substitution with the standard output of the command, with any
trailing newlines deleted. Embedded newlines are not deleted, but they
may be removed during word splitting.

....
franky ~> echo `date`
Thu Feb 6 10:06:20 CET 2003
....

When the old-style backquoted form of substitution is used, backslash
retains its literal meaning except when followed by ``$'', ```'', or
``\''. The first backticks not preceded by a backslash terminates the
command substitution. When using the ``$(COMMAND)'' form, all characters
between the parentheses make up the command; none are treated specially.

Command substitutions may be nested. To nest when using the backquoted
form, escape the inner backticks with backslashes.

If the substitution appears within double quotes, word splitting and
file name expansion are not performed on the results.

[[sect_03_04_05]]
Arithmetic expansion
~~~~~~~~~~~~~~~~~~~~

Arithmetic expansionexpansionarithmetic expansion allows the evaluation
of an arithmetic expressionarithmetic expansionsyntax and the
substitution of the result. The format for arithmetic expansion is:

$(( EXPRESSION ))

The expression is treated as if it were within double quotes, but a
double quote inside the parentheses is not treated specially. All tokens
in the expression undergo parameter expansion, command substitution, and
quote removal. Arithmetic substitutions may be nested.

Evaluation of arithmetic expressions is done in fixed-width integers
with no check for overflow - although division by zero is trapped and
recognized as an error. The operators are roughly the same as in the C
programming language. In order of decreasing precedencearithmetic
expansionoperators, the list looks like this:

.Arithmetic operators
[cols=",",options="header",]
|===========================================================
|Operator |Meaning
|VAR++ and VAR-- |variable post-increment and post-decrement
|++VAR and --VAR |variable pre-increment and pre-decrement
|- and + |unary minus and plus
|! and ~ |logical and bitwise negation
|** |exponentiation
|*, / and % |multiplication, division, remainder
|+ and - |addition, subtraction
|<< and >> |left and right bitwise shifts
|<=, >=, < and > |comparison operators
|== and != |equality and inequality
|& |bitwise AND
|^ |bitwise exclusive OR
|| |bitwise OR
|&& |logical AND
||| |logical OR
|expr ? expr : expr |conditional evaluation
|=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^= and |= |assignments
|, |separator between expressions
|===========================================================

Shell variables are allowed as operands; parameter expansion is
performed before the expression is evaluated. Within an expression,
shell variables may also be referenced by name without using the
parameter expansion syntax. The value of a variable is evaluated as an
arithmetic expression when it is referenced. A shell variable need not
have its integer attribute turned on to be used in an expression.

Constants with a leading 0 (zero) are interpreted as octal numbers. A
leading ``0x'' or ``0X'' denotes hexadecimal. Otherwise, numbers take
the form ``[BASE'#']N'', where ``BASE'' is a decimal number between 2
and 64 representing the arithmetic base, and N is a number in that base.
If ``BASE'#''' is omitted, then base 10 is used. The digits greater than
9 are represented by the lowercase letters, the uppercase letters,
``@'', and ``_'', in that order. If ``BASE'' is less than or equal to
36, lowercase and uppercase letters may be used interchangably to
represent numbers between 10 and 35.

Operators are evaluated in order of precedence. Sub-expressions in
parentheses are evaluated first and may override the precedence rules
above.

Wherever possible, Bash users should try to use the syntax with square
brackets:

$[ EXPRESSION ]

However, this will only calculate the result of _EXPRESSION_, and do no
tests:

....
franky ~> echo $[365*24]
8760
....

See link:#sect_07_01_02_02[???], among others, for practical examples in
scripts.

[[sect_03_04_06]]
Process substitution
~~~~~~~~~~~~~~~~~~~~

Process substitutionexpansionprocess substitution is supported on
systems that support named pipes (FIFOs) or the `/dev/fd` method of
naming open files. It takes the formprocess substitutionsyntax of

<(LIST)

or

>(LIST)

The process `LIST` is run with its input or output connected to a FIFO
or some file in `/dev/fd`. The name of this file is passed as an
argument to the current command as the result of the expansion. If the
``>(LIST)'' form is used, writing to the file will provide input for
`LIST`. If the ``<(LIST)'' form is used, the file passed as an argument
should be read to obtain the output of `LIST`. Note that no space may
appear between the < or > signs and the left parenthesis, otherwise the
construct would be interpreted as a redirection.

When available, process substitution is performed simultaneously with
parameter and variable expansion, command substitution, and arithmetic
expansion.

More information in link:#sect_08_02_03[???].

[[sect_03_04_07]]
Word splitting
~~~~~~~~~~~~~~

The shellexpansionword splitting scans the results of parameter
expansion, command substitution, and arithmetic expansion that did not
occur within double quotes for word splitting.

The shellword splittinginput field separator treats each character of
`$IFSvariablesIFS` as a delimiter, and splits the results of the other
expansions into words on these characters. If
`IFSinput field separatorword splitting` is unset, or its value is
exactly ``'<space><tab><newline>''', the default, then any sequence of
`IFS` characters serves to delimit words. If `IFS` has a value other
than the default, then sequences of the whitespace characters ``space''
and ``Tab'' are ignored at the beginning and end of the word, as long as
the whitespace character is in the value of `IFS` (an `IFS` whitespace
character). Any character in `IFS` that is not `IFS` whitespace, along
with any adjacent `IF` whitespace characters, delimits a field. A
sequence of `IFS` whitespace characters is also treated as a delimiter.
If the value of `IFS` is null, no word splitting occurs.

Explicit null argumentsargumentsnull arguments (``""'' or ``'''') are
retained. Unquoted implicit null arguments, resulting from the expansion
of parameters that have no values, are removed. If a parameter with no
value is expanded within double quotes, a null argument results and is
retained.

__________________________________________________
*Note*

If no expansion occurs, no splitting is performed.
__________________________________________________

[[sect_03_04_08]]
File name expansion
~~~~~~~~~~~~~~~~~~~

After word splittingexpansionfile name expansion, unless the `-f` option
has been set (see link:#sect_02_03_02[???]), Bash scans each word for
the charactersfile name expansioncharacters ``*'', ``?'', and ``[''. If
one of these characters appears, then the word is regarded as a
_PATTERN_, and replaced with an alphabetically sorted list of file names
matching the pattern. If no matching file names are found, and the shell
option `nullgloboptionsnullglob` is disabled, the word is left
unchanged. If the `nullglob` option is set, and no matches are found,
the word is removed. If the shell optionoptionsnocaseglob `nocaseglob`
is enabled, the match is performed without regard to the case of
alphabetic characters.

When a pattern is used for file name generation, the character ``.'' at
the start of a file name or immediately following a slash must be
matched explicitly, unless the shell option `dotglob` is set. When
matching a file name, the slash character must always be matched
explicitly. In other cases, the ``.'' character is not treated
specially.

The `GLOBIGNOREvariablesGLOBIGNORE` shell variable may be used to
restrict the set of file names matching a pattern. If `GLOBIGNORE` is
set, each matching file name that also matches one of the patterns in
`GLOBIGNORE` is removed from the list of matches. The file names `.` and
`..` are always ignored, even when `GLOBIGNORE` is set. However, setting
`GLOBIGNORE` has the effect of enabling the `dotglob` shell option, so
all other file names beginning with a ``.'' will match. To get the old
behavior of ignoring file names beginning with a ``.'', make ``.*'' one
of the patterns in `GLOBIGNORE`. The `dotglob` option is disabled when
`GLOBIGNORE` is unset.

[[sect_03_05]]
Aliases
-------

[[sect_03_05_01]]
What are aliases?
~~~~~~~~~~~~~~~~~

An alias allows a string to be substituted for a word when it is used as
the first word of a simple command. The shell maintains a list of
aliasesaliasesdefinition that may be set and unset with the `alias` and
`unalias` built-inaliasesdelete an alias commands. Issue the `alias`
without options to display a list of aliases known to the current
shellaliasesexamples.

....
franky: ~> alias
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias PAGER='less -r'
alias Txterm='export TERM=xterm'
alias XARGS='xargs -r'
alias cdrecord='cdrecord -dev 0,0,0 -speed=8'
alias e='vi'
alias egrep='grep -E'
alias ewformat='fdformat -n /dev/fd0u1743; ewfsck'
alias fgrep='grep -F'
alias ftp='ncftp -d15'
alias h='history 10'
alias fformat='fdformat /dev/fd0H1440'
alias j='jobs -l'
alias ksane='setterm -reset'
alias ls='ls -F --color=auto'
alias m='less'
alias md='mkdir'
alias od='od -Ax -ta -txC'
alias p='pstree -p'
alias ping='ping -vc1'
alias sb='ssh blubber'
alias sl='ls'
alias ss='ssh octarine'
alias tar='gtar'
alias tmp='cd /tmp'
alias unaliasall='unalias -a'
alias vi='eval `resize`;vi'
alias vt100='export TERM=vt100'
alias which='type'
alias xt='xterm -bg black -fg white &'

franky ~>
....

Aliases are useful for specifying the default version of a command that
exists in several versions on your system, or to specify default options
to a command. Another use for aliasesaliasesusage is for correcting
incorrect spelling.

The first word of each simple command, if unquoted, is checked to see if
it has an alias. If so, that word is replaced by the text of the alias.
The alias name and the replacement text may contain any valid shell
input, including shell metacharacters, with the exception that the alias
name may not contain ``=''. The first word of the replacement text is
tested for aliases, but a word that is identical to an alias being
expanded is not expanded a second time. This means that one may alias
`ls` to `ls -F`, for instance, and Bash will not try to recursively
expand the replacement text. If the last character of the alias value is
a space or tab character, then the next command word following the alias
is also checked for alias expansion.

Aliases are not expanded when the shell is not interactive, unless the
`expand_aliases` optionaliasesexpand_aliases is set using the `shopt`
shell built-in.

[[sect_03_05_02]]
Creating and removing aliases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Aliases are created using the `alias` shellaliasescreation built-in. For
permanent use, enter the `alias` in one of your shell initialization
files; if you just enter the alias on the command line, it is only
recognized within the current shell.

....
franky ~> alias dh='df -h'

franky ~> dh
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda7             1.3G  272M 1018M  22% /
/dev/hda1             121M  9.4M  105M   9% /boot
/dev/hda2              13G  8.7G  3.7G  70% /home
/dev/hda3              13G  5.3G  7.1G  43% /opt
none                  243M     0  243M   0% /dev/shm
/dev/hda6             3.9G  3.2G  572M  85% /usr
/dev/hda5             5.2G  4.3G  725M  86% /var

franky ~> unalias dh

franky ~> dh
bash: dh: command not found

franky ~>
....

Bash always reads at least one complete line of input before executing
any of the commands on that line. Aliases are expanded when a command is
read, not when it is executed. Therefore, an alias definition appearing
on the same line as another command does not take effect until the next
line of input is read. The commands following the alias definition on
that line are not affected by the new alias. This behavior is also an
issue when functions are executed. Aliases are expanded when a function
definition is read, not when the function is executed, because a
function definition is itself a compound command. As a consequence,
aliasesaliasesaliases in functions defined in a function are not
available until after that function is executed. To be safe, always put
alias definitions on a separate line, and do not use `alias` in compound
commands.

Aliases are not inherited by child processes. Bourne shell (`sh`) does
not recognize aliases.

More about functions is in link:#chap_11[???].

________________________________________________________________________________________________________________________________________________________________________________
*Tip*

Aliases are looked up after functions and thus resolving is slower.
While aliases are easier to understand, shell functions are preferred
over aliases for almost every purpose.
________________________________________________________________________________________________________________________________________________________________________________

[[sect_03_06]]
More Bash options
-----------------

[[sect_03_06_01]]
Displaying options
~~~~~~~~~~~~~~~~~~

We already discussed a couple of Bash options that are useful for
debugging your scripts. In this section, we will take a more in-depth
view of the Bash options.

Use the `-o` option to `set` to display all shelloptionsdisplay all
options options:

....
willy:~> set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
posix           off
privileged      off
verbose         off
vi          off
xtrace          off
....

See the Bash Info pages, section Shell Built-in Commands > The Set
Built-in for a description of each option. A lot of options have
one-character shorthands: the `xtrace` option, for instance, is equal to
specifying `set -x`.

[[sect_03_06_02]]
Changing options
~~~~~~~~~~~~~~~~

Shell options can either be set differentoptionschanging options from
the default upon calling the shell, or be set during shell operation.
They may also be included in the shell resource configuration files.

The following command executes a script in POSIX-compatible mode:

....
willy:~/scripts> bash --posix script.sh
....

For changing the current environment temporarily, or for use in a
script, we would rather use `set`. Use _-_ (dash) for enabling an
option, _+_ for disabling:

....
willy:~/test> set -o noclobber

willy:~/test> touch test

willy:~/test> date > test
bash: test: cannot overwrite existing file

willy:~/test> set +o noclobber

willy:~/test> date > test
....

The above example demonstrates the `noclobber` optionoptionsnoclobber,
which prevents existing files from being overwritten by redirection
operations. The same goes for one-character options, for instance `-u`,
which will treat unset variables as an error when set, and exits a
non-interactive shell upon encountering such errors:

....
willy:~> echo $VAR


willy:~> set -u

willy:~> echo $VAR
bash: VAR: unbound variable
....

This option is also useful for detecting incorrectvariablesdetect
content assignment content assignment to variables: the same error will
also occur, for instance, when assigning a character string to a
variable that was declared explicitly as one holding only integer
values.

One last example follows, demonstrating the `noglob` option, which
prevents special characters from being expanded:

....
willy:~/testdir> set -o noglob

willy:~/testdir> touch *

willy:~/testdir> ls -l *
-rw-rw-r--    1 willy    willy      0 Feb 27 13:37 *
....

[[sect_03_07]]
Summary
-------

The Bash environment can be configured globally and on a per user basis.
Various configuration files are used to fine-tune the behavior of the
shell.

These files contain shell options, settings for variables, function
definitions and various other building blocks for creating ourselves a
cosy environment.

Except for the reserved Bourne shell, Bash and special parameters,
variable names can be chosen more or less freely.

Because a lot of characters have double or even triple meanings,
depending on the environment, Bash uses a system of quoting to take away
special meaning from one or multiple characters when special treatment
is not wanted.

Bash uses various methods of expanding command line entries in order to
determine which commands to execute.

[[sect_03_08]]
Exercises
---------

For this exercise, you will need to read the `useradd` man pages,
because we are going to use the `/etc/skel` directory to hold default
shell configuration files, which are copied to the home directory of
each newly added user.

First we will do some general exercises on setting and displaying
variables.

1.  Create 3 variables, `VAR1`, `VAR2` and `VAR3`; initialize them to
hold the values ``thirteen'', ``13'' and ``Happy Birthday''
respectively.
2.  Display the values of all three variables.
3.  Are these local or global variables?
4.  Remove `VAR3`.
5.  Can you see the two remaining variables in a new terminal window?
6.  Edit `/etc/profile` so that all users are greeted upon login (test
this).
7.  For the _root_ account, set the prompt to something like ``Danger!!
root is doing stuff in \w'', preferably in a bright color such as red or
pink or in reverse video mode.
8.  Make sure that newly created users also get a nice personalized
prompt which informs them on which system in which directory they are
working. Test your changes by adding a new user and logging in as that
user.
9.  Write a script in which you assign two integer values to two
variables. The script should calculate the surface of a rectangle which
has these proportions. It should be aired with comments and generate
elegant output.

Don't forget to `chmod` your scripts!
